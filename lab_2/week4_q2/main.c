/* DriverLib includes. */
#include <ti/devices/msp432p4xx/driverlib/driverlib.h>

/* Standard includes. */
#include <stdint.h>
#include <stdbool.h>

enum states
{
    OFF,
    RED,
    GREEN,
    BLUE,
    YELLOW,
    PURPLE,
    CYAN,
    WHITE,
} state;

int main(void)
{
    MAP_WDT_A_holdTimer();

    /* Configure the output GPIO pins driving the LEDs. */
    GPIO_setAsOutputPin(GPIO_PORT_P2, GPIO_PIN0 | GPIO_PIN1 | GPIO_PIN2);
    GPIO_setOutputLowOnPin(GPIO_PORT_P2, GPIO_PIN0 | GPIO_PIN1 | GPIO_PIN2);

    /* Configure input GPIO pins, P1.1 for BUTTON1 and BUTTON2 P1.4. */
    GPIO_setAsInputPinWithPullUpResistor(GPIO_PORT_P1, GPIO_PIN1 | GPIO_PIN4);
    GPIO_interruptEdgeSelect(GPIO_PORT_P1, GPIO_PIN1 | GPIO_PIN4,
    GPIO_LOW_TO_HIGH_TRANSITION);
    GPIO_clearInterruptFlag(GPIO_PORT_P1, GPIO_PIN1 | GPIO_PIN4);
    GPIO_enableInterrupt(GPIO_PORT_P1, GPIO_PIN1 | GPIO_PIN4);
    Interrupt_enableInterrupt(INT_PORT1);
    Interrupt_enableMaster();

    state = OFF;
    while (1)
    {
        switch (state)
        {
        case OFF:
            GPIO_setOutputLowOnPin(GPIO_PORT_P2,
            GPIO_PIN0 | GPIO_PIN1 | GPIO_PIN2);
            break;

        case RED:
            GPIO_setOutputHighOnPin(GPIO_PORT_P2, GPIO_PIN0);
            GPIO_setOutputLowOnPin(GPIO_PORT_P2, GPIO_PIN1 | GPIO_PIN2);
            break;

        case GREEN:
            GPIO_setOutputHighOnPin(GPIO_PORT_P2, GPIO_PIN1);
            GPIO_setOutputLowOnPin(GPIO_PORT_P2, GPIO_PIN0 | GPIO_PIN2);
            break;

        case BLUE:
            GPIO_setOutputHighOnPin(GPIO_PORT_P2, GPIO_PIN2);
            GPIO_setOutputLowOnPin(GPIO_PORT_P2, GPIO_PIN0 | GPIO_PIN1);
            break;

        case YELLOW:
            GPIO_setOutputHighOnPin(GPIO_PORT_P2, GPIO_PIN0 | GPIO_PIN1);
            GPIO_setOutputLowOnPin(GPIO_PORT_P2, GPIO_PIN2);
            break;

        case PURPLE:
            GPIO_setOutputHighOnPin(GPIO_PORT_P2, GPIO_PIN0 | GPIO_PIN2);
            GPIO_setOutputLowOnPin(GPIO_PORT_P2, GPIO_PIN1);
            break;

        case CYAN:
            GPIO_setOutputHighOnPin(GPIO_PORT_P2, GPIO_PIN1 | GPIO_PIN2);
            GPIO_setOutputLowOnPin(GPIO_PORT_P2, GPIO_PIN0);
            break;

        case WHITE:
            GPIO_setOutputHighOnPin(GPIO_PORT_P2,
            GPIO_PIN0 | GPIO_PIN1 | GPIO_PIN2);
            break;
        }
    }

    return 0;
}

/* ISR to handle IRQs generated by pins in PORT1. */
void PORT1_IRQHandler(void)
{
    uint16_t status = GPIO_getEnabledInterruptStatus(GPIO_PORT_P1);
    GPIO_clearInterruptFlag(GPIO_PORT_P1, status);

    /* Check for the correct pin that generated the interrupt. */
    if (status & GPIO_PIN1)
    {
        switch (state)
        {
        case OFF:
            state = RED;
            break;

        case GREEN:
            state = BLUE;
            break;

        case YELLOW:
            state = PURPLE;
            break;

        case CYAN:
            state = WHITE;
            break;
        }
    }
    else if (status & GPIO_PIN4)
    {
        switch (state)
        {
        case RED:
            state = GREEN;
            break;

        case BLUE:
            state = YELLOW;
            break;

        case PURPLE:
            state = CYAN;
            break;

        case WHITE:
            state = OFF;
            break;
        }
    }

    return;
}
