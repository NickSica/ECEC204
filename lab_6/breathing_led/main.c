/* Description: Skeleton code for friend or foe classifier
 *
 * Author: Naga Kandasamy
 * Date created: August 17, 2019
*******************************************************************************/
/* DriverLib includes */
#include <ti/devices/msp432p4xx/driverlib/driverlib.h>

/* Standard includes */
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>

/* Global variables shared between the main code and the ISR. */
uint16_t increase, count = 0;
float duty_cycle = 0.0f;
int period = 3000;

/* Configuration parameters for input capture mode. */
const Timer_A_UpModeConfig upModeConfig =
{
 TIMER_A_CLOCKSOURCE_ACLK,                 // Clock source is SMCLK
 TIMER_A_CLOCKSOURCE_DIVIDER_1,             // 1:1 divider ratio for the counter clock
 12800,
 TIMER_A_TAIE_INTERRUPT_ENABLE,            // Disable overflow ISR
 TIMER_A_CCIE_CCR0_INTERRUPT_DISABLE,
 TIMER_A_DO_CLEAR
};

Timer_A_PWMConfig pwmConfig =
{
 TIMER_A_CLOCKSOURCE_SMCLK,                 // Clock source
 TIMER_A_CLOCKSOURCE_DIVIDER_1,             // Divider ratio, 1:1
 3000,                                      // Timer period which will stored in CCR0
 TIMER_A_CAPTURECOMPARE_REGISTER_1,         // Compare register to use
 TIMER_A_OUTPUTMODE_RESET_SET,              // Output mode for PWM signal
 0                                         // Duty cycle length which will be stored in CCR1
};


/* ISR to handle overflow events at Timer A2. */
void TA2_N_IRQHandler(void)
{
    Timer_A_clearInterruptFlag(TIMER_A2_BASE);
    if(increase == 1)
    {
        duty_cycle += 0.05;
        if(duty_cycle > 0.5)
        {
            duty_cycle = 0.45;
            increase = 0;
        }

        pwmConfig.dutyCycle = period * duty_cycle;
        Timer_A_generatePWM(TIMER_A0_BASE, &pwmConfig);
    }
    else
    {
        duty_cycle -= 0.05;
        if(duty_cycle < 0.0)
        {
            duty_cycle = 0.05;
            increase = 1;
        }

        pwmConfig.dutyCycle = period * duty_cycle;
        Timer_A_generatePWM(TIMER_A0_BASE, &pwmConfig);
    }

    return;
}

int main(void)
{
    /* Stop Watchdog timer.  */
    MAP_WDT_A_holdTimer();

    /* Initialize the low-speed auxiliary clock system. */
    CS_setReferenceOscillatorFrequency(CS_REFO_32KHZ); // Reference oscillator is set to 128KHz
    CS_initClockSignal(CS_ACLK, CS_REFOCLK_SELECT, CS_CLOCK_DIVIDER_1); // Auxiliary clock derives from reference
    CS_initClockSignal(CS_SMCLK, CS_REFOCLK_SELECT, CS_CLOCK_DIVIDER_1);

    /* Configure timer in continuous mode with input capture. */
    Timer_A_configureUpMode(TIMER_A2_BASE, &upModeConfig);
    Interrupt_enableInterrupt(INT_TA2_N);
    Timer_A_startCounter(TIMER_A2_BASE, TIMER_A_UP_MODE);  // Start timer.

    /* Configure P2.4 as primary module output for PWM signal generated by Timer A0. */
    GPIO_setAsOutputPin(GPIO_PORT_P2, GPIO_PIN4);
    GPIO_setAsPeripheralModuleFunctionOutputPin(GPIO_PORT_P2, GPIO_PIN4, GPIO_PRIMARY_MODULE_FUNCTION);
    Timer_A_generatePWM(TIMER_A0_BASE, &pwmConfig); // Generate PWM signal.
    Interrupt_enableMaster();

     while(1);
}



